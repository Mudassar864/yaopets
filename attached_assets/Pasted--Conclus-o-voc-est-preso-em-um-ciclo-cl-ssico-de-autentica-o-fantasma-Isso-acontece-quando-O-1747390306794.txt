 ConclusÃ£o: vocÃª estÃ¡ preso em um ciclo clÃ¡ssico de autenticaÃ§Ã£o "fantasma"
Isso acontece quando:

O servidor cria a sessÃ£o/token com sucesso

Mas o cliente nÃ£o consegue acessÃ¡-la (por cookie, storage ou contexto)

E ao recarregar a pÃ¡gina, a verificaÃ§Ã£o detecta â€œusuÃ¡rio nÃ£o autenticadoâ€ â†’ volta para /login

âœ… DiagnÃ³stico final com quase 100% de chance de identificar o problema:
ğŸ§ª VerificaÃ§Ã£o 1 â€” Token realmente foi armazenado no navegador?
Abra o DevTools â†’ aba â€œApplicationâ€ â†’ â€œCookiesâ€

Olhe os cookies no domÃ­nio da aplicaÃ§Ã£o

VocÃª deve ver algo como:

lua
Copiar
Editar
next-auth.session-token
ou
__Secure-next-auth.session-token
Se nÃ£o aparecer nenhum desses:

O navegador nÃ£o estÃ¡ aceitando o cookie de sessÃ£o.

ğŸ§ª VerificaÃ§Ã£o 2 â€” O cookie estÃ¡ sendo bloqueado silenciosamente?
Se estiver rodando localhost ou 127.0.0.1, mas a configuraÃ§Ã£o do cookie estÃ¡ assim:

js
Copiar
Editar
cookies: {
  sessionToken: {
    name: "__Secure-next-auth.session-token",
    options: {
      httpOnly: true,
      secure: true, // <- esse aqui bloqueia em HTTP!
      sameSite: "lax",
    },
  },
}
âš ï¸ Isso NÃƒO funciona em ambiente local com HTTP (apenas HTTPS).

SoluÃ§Ã£o:
No next-auth ou backend, garanta:

ts
Copiar
Editar
secure: process.env.NODE_ENV === "production"
ğŸ§ª VerificaÃ§Ã£o 3 â€” Middleware sempre redireciona de volta pro login?
Se tiver middleware.ts assim:

ts
Copiar
Editar
export async function middleware(req) {
  const token = await getToken({ req, secret: process.env.SECRET });
  if (!token) {
    return NextResponse.redirect(new URL("/login", req.url));
  }
}
E getToken() nÃ£o encontra o cookie, entÃ£o o usuÃ¡rio sempre Ã© chutado pra /login, mesmo apÃ³s autenticaÃ§Ã£o bem-sucedida.

Testes:

Comente esse middleware temporariamente e veja se o login te leva para /home

Se funcionar, Ã© 100% erro de cookie/token nÃ£o sendo lido

ğŸ§ª VerificaÃ§Ã£o 4 â€” PÃ¡gina de login ou home tem um useEffect que redireciona errado?
tsx
Copiar
Editar
useEffect(() => {
  if (!session && status !== "loading") {
    router.push("/login");
  }
}, [session, status]);
Se session estiver momentaneamente null ou undefined apÃ³s o login, esse redirecionamento acontece antes do estado se estabilizar.

SoluÃ§Ã£o:

tsx
Copiar
Editar
if (status === "loading") return null;
if (!session) {
  router.push("/login");
  return null;
}
ğŸ§ª VerificaÃ§Ã£o 5 â€” Frontend e backend estÃ£o em domÃ­nios diferentes?
Se vocÃª roda:

frontend em localhost:3000

backend em localhost:5000

Mas nÃ£o configurou corretamente CORS e credentials: "include" nas fetch/axios, os cookies nÃ£o sÃ£o gravados.

âœ… Resumo de aÃ§Ãµes prÃ¡ticas agora:
Verifique se o cookie de sessÃ£o foi gravado apÃ³s login.

Confirme se a flag secure estÃ¡ desabilitada em ambiente de dev (HTTPS).

Teste comentar o middleware.ts inteiro â€” se o login funcionar, o problema Ã© nele.

Logue o session na pÃ¡gina /home e na /login para entender o estado real.

Coloque status === "loading" como condiÃ§Ã£o de bloqueio do redirecionamento.

Evite usar __Secure- como prefixo em cookies em localhost.